#include "antidebug.h"
#include "Helper.h"

antidebug::antidebug(void)
{
}


antidebug::~antidebug(void)
{
}

void antidebug::startDetect(){
	printf("========= Checks for Anti-Debugger Techniques =======\n");
	isDebuggerPresent();
	isCheckRemoteDebuggerPresent();
	isOutputDebugString();
	isProcessDebugPort();
	isSystemKernelDebuggerInformation();
	checkNtGlobalFlag();
	findWindows();
	selfDebug();
	unHandledExceptionFilter();
	isSeDebugPrivilege();

	// last one
	//multipleDesktop();
	//blockInput();
	detachDebugger();

	checkRegistry();
	checkProcess();
	checkFile();

	printf("\n");
}

void antidebug::isDebuggerPresent(){
	BOOL result = FALSE;
	
	HINSTANCE kern_lib = LoadLibraryEx(L"kernel32.dll", NULL, 0 );
	if( kern_lib ) {
		FARPROC lIsDebuggerPresent = GetProcAddress( kern_lib, "IsDebuggerPresent" );
		if( lIsDebuggerPresent && lIsDebuggerPresent() ) {
			result = TRUE;
		}
		FreeLibrary( kern_lib );
	}

	if(result){
		printf("Anti-Debug: IsDebuggerPresent exists.\n");
	}
	else{
		FILE *pfile = fopen("Debug-createdByMalware.txt", "w");
		fprintf(pfile, "i am created by paranoidmalware.exe");
		//pfile->close();
	}
}

void antidebug::isCheckRemoteDebuggerPresent(){
		BOOL result = false;;
		BOOL WINAPI CheckRemoteDebuggerPresent(__in HANDLE hProcess,
           __inout PBOOL pbDebuggerPresent);

		BOOL pbIsPresent = FALSE;
		CheckRemoteDebuggerPresent(GetCurrentProcess(), &pbIsPresent);
		if (pbIsPresent) {
			result = true;
		}

		if(result){
			printf("Anti-Debug: CheckRemoteDebuggerPresent.\n");
		}
}

// If there is debugger attached to this process, the value for setlasterror will not change
// as outputdebugstring is normal! if it changes, means debugger does not exist.
void antidebug::isOutputDebugString(){
	void WINAPI OutputDebugString(__in_opt  LPCTSTR lpOutputString);
	BOOL result = false;

	OutputDebugString(L"random");
	if(GetLastError() == 0) {
		result = true;
	}

	if(result){
		printf("Anti-Debug: OutputDebugString.\n");
	}
}

// Silence Version of IsDebuggerPresent
void antidebug::isProcessDebugPort(){
	bool result = false;
	int retVal = 0;

	typedef NTSTATUS (NTAPI *_NtQueryInformationProcess)(
		HANDLE ProcessHandle,
		DWORD ProcessInformationClass, /* can't be bothered defining the whole enum */
		PVOID ProcessInformation,
		DWORD ProcessInformationLength,
		PDWORD ReturnLength
    );

	_NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)
        GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");

	NtQueryInformationProcess(GetCurrentProcess(), 0x07, &retVal, 4, NULL);

	if(retVal!=0){
		result = true;
	}

	if(result){
		printf("Anti-Debug: ProcessDebugPort is triggered.\n");
	}
}

void antidebug::detachDebugger(){
	bool result = false;
	int retVal = 0;

	typedef NTSTATUS (NTAPI *_NtSetInformationThread)(
		HANDLE ThreadHandle,
		DWORD ThreadInformationClass, /* can't be bothered defining the whole enum */
		PVOID ThreadInformation,
		ULONG ThreadInformationLength
    );

	_NtSetInformationThread NtSetInformationThread = (_NtSetInformationThread)
        GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetInformationThread");

	NtSetInformationThread(GetCurrentThread(), 0x11, 0, 0);

	printf("Anti-Debug: Detach Debugger\n");
}

void antidebug::findWindows(){
	Helper h;
	if(h.findWindows(L"OLLYDBG")){
		printf("Anti-Debug: OllyDbg exists.\n");
	}
	if(h.findWindows(L"TIdaWindows")){
		printf("Anti-Debug: IDA Pro exists.\n");
	}
	if(h.findWindows(L"WinDbgFrameClass")){
		printf("Anti-Debug: WinDbg exists.\n");
	}
}

void antidebug::BeDebugged(){
	char IsDbgPresent = 0;
	bool result = false;
	__asm {
		 mov eax, fs:[30h]
		 mov al, [eax + 2h]
		 mov IsDbgPresent, al
	}

	if(IsDbgPresent)
	{
		result = true;	
	}

	if(result){
		printf("Anti-Debug: IsDebuggerPresent detected\n");
	}
}

//http://www.codeproject.com/Articles/29469/Introduction-Into-Windows-Anti-Debugging
void antidebug::checkNtGlobalFlag(){
	unsigned long NtGlobalFlags = 0;
	BOOL result = false;

	__asm {

		mov eax, fs:[30h]
		mov eax, [eax + 68h]
		mov NtGlobalFlags, eax
	}


	if(NtGlobalFlags & 0x70)
	{
		result = true;
	}

	if(result){
			printf("Anti-Debug: NtGlobalFlag is set. Debugger detected\n");
	}
}

// reference: http://shangdi.googlecode.com/svn/trunk/code/LicenseLib/AntiDebug.cpp
void antidebug::isSystemKernelDebuggerInformation(){
	bool result = false;
	typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION { 
		BOOLEAN DebuggerEnabled; 
		BOOLEAN DebuggerNotPresent; 
	} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION; 
	enum SYSTEM_INFORMATION_CLASS { SystemKernelDebuggerInformation = 35 }; 
	typedef NTSTATUS  (__stdcall *ZW_QUERY_SYSTEM_INFORMATION)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass, IN OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength); 

	ZW_QUERY_SYSTEM_INFORMATION ZwQuerySystemInformation;
	SYSTEM_KERNEL_DEBUGGER_INFORMATION Info;

	HMODULE hmd = GetModuleHandle(L"ntdll.dll");
	if (hmd != NULL) {
		ZwQuerySystemInformation = (ZW_QUERY_SYSTEM_INFORMATION)GetProcAddress(hmd, "ZwQuerySystemInformation");
		if (ZwQuerySystemInformation) {
			if ((NTSTATUS)0L == ZwQuerySystemInformation(SystemKernelDebuggerInformation, &Info, sizeof(Info), NULL)) {
				if (Info.DebuggerEnabled&&!Info.DebuggerNotPresent) {
					result = true;
				}
			}
		}
	}

	if(result){
		printf("Anti-Debug: SystemKernelDebuggerInformation is set. Debugger detected\n");
	}
}

// reference: http://www.codeproject.com/Articles/30815/An-Anti-Reverse-Engineering-Guide#SelfDebugging
void antidebug::selfDebug(){
	
	HANDLE hnd = NULL;
	DEBUG_EVENT deEvent;
	PROCESS_INFORMATION pi;
	STARTUPINFO startInfo;

	// initialize
	ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	ZeroMemory(&startInfo, sizeof(STARTUPINFO));
	ZeroMemory(&deEvent, sizeof(DEBUG_EVENT));

	GetStartupInfo(&startInfo);

	//Clone this process and debug our parent process
	CreateProcess(NULL, GetCommandLine(), NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &startInfo, &pi);
	ContinueDebugEvent(pi.dwProcessId, pi.dwThreadId, DBG_CONTINUE);
	WaitForDebugEvent(&deEvent, INFINITE);

	printf("Anti-Debug: This process is self-debugging now to prevent other debuggers from attaching.\n");
}

LONG WINAPI UnhandledExcepFilter(PEXCEPTION_POINTERS pExcepPointers)
{
    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)
          pExcepPointers->ContextRecord->Eax);

    pExcepPointers->ContextRecord->Eip += 2;

    return EXCEPTION_CONTINUE_EXECUTION;
}


void antidebug::unHandledExceptionFilter(){
	SetUnhandledExceptionFilter(UnhandledExcepFilter);
    __asm{xor eax, eax}
    __asm{div eax}

	printf("Anti-Debug: UnhandledExceptionFilter: There is no debugger attached.\n");
}

// Check if CRCSS.exe can be open
// If it can be opened, a debugger is attached to make it accessible
void antidebug::isSeDebugPrivilege(){
	HANDLE csrss = NULL;
	Helper h;
	csrss = OpenProcess(PROCESS_ALL_ACCESS, false, h.getProcessID("csrss.exe"));

	if(csrss!=NULL){
		printf("Anti-Debug: SeDebugPrivilege flag on for CSRSS.exe. AntiDebug exists.");
	}
}

// block mouse and keyboard
void antidebug::blockInput(){
	BlockInput(true);
	printf("Anti-Debug: Mouse/Key input is blocked.\n");
}

// create multiple desktop
void antidebug::multipleDesktop(){
	HDESK hdeskOriginalThread = GetThreadDesktop(GetCurrentThreadId());
    HDESK hdeskOriginalInput = OpenInputDesktop(0, FALSE, DESKTOP_SWITCHDESKTOP);
	HDESK hDesk=CreateDesktop(L"NewDesktop",NULL,NULL,NULL,GENERIC_ALL,NULL);
	
	if(hDesk!=NULL) {
		SetThreadDesktop(hDesk);
		//SwitchDesktop(hDesk);MessageBox(NULL, TEXT("MessageBox on private desktop"), TEXT("Private Desktop"), MB_OK);
		SwitchDesktop(hdeskOriginalInput);
		SetThreadDesktop(hdeskOriginalThread);
		CloseDesktop(hDesk);
		printf("Anti-Debug: Created the program in another Desktop.\n");
	}
}


// offset 0x10 at heap
void antidebug::checkHeapflags(){
	// check for Windows 7
	DWORD ver = GetVersion();
	DWORD first = (DWORD) (LOBYTE(LOWORD(ver)));
	DWORD second = (DWORD) (HIBYTE(LOWORD(ver)));

	// 6.1 = Windows 7
	if(first > 6 || (first==6 && second>=1)){
		__asm
		{
			mov eax, fs:[18h]			
			mov eax, [eax + 30h]		;PEB
			mov eax, [eax + 18h]		
			cmp [eax + 44h],0			;heap force flags 
			jne DebuggerDetected
		}
	}
	else{
		__asm
		{
			mov eax, fs:[18h]			;TEB
			mov eax, [eax + 30h]	;PEB
			mov eax, [eax + 18h]	;process heap
			cmp [eax + 10h],0		;heap force flags
			jne DebuggerDetected
		}
	}
	
	return;
	__asm{DebuggerDetected:}
	printf("Anti-Debug: ForceFlag is on.");
}

void antidebug::debuggerPrefixCheck(){
	__try
    {
        __asm __emit 0xF3 // 0xF3 0x64 disassembles as PREFIX REP:
        __asm __emit 0x64
        __asm __emit 0xF1 // One byte INT 1
    }
    __except(EXCEPTION_EXECUTE_HANDLER){return;}

	printf("Antidebug: VS2008 Debugger or OllyDbg exists.\n");
}

// crash ollydbg when stepping through
void antidebug::isOutputDebugStringCrash(){
	OutputDebugString( TEXT("%s%s%s%s%s%s%s%s%s%s%s")
                TEXT("%s%s%s%s%s%s%s%s%s%s%s%s%s")
                TEXT("%s%s%s%s%s%s%s%s%s%s%s%s%s")
                TEXT("%s%s%s%s%s%s%s%s%s%s%s%s%s") );
}


void antidebug::checkRegistry(){
	// none yet
}

void antidebug::checkProcess(){
	Helper h;

	if(h.isProcessExists("syserapp.exe")){
		printf("Anti-Debug: syserapp.exe exists.\n");
	}
	if(h.isProcessExists("ollydbg.exe")){
		printf("Anti-Debug: ollydbg.exe exists.\n");
	}
	if(h.isProcessExists("idag.exe")){
		printf("Anti-Debug: IDA pro exists.\n");	
	}// idapro
}

void antidebug::checkFile(){
	Helper h;
	std::string driverPath = "C:\\Windows\\system32\\";
	printf("Check Files.\n");
	h.isFileExists(driverPath + "dbghelp.dll");
	h.isFileExists(driverPath + "drivers\\Syser.sys");
	printf("\n");
}
#include "Helper.h"

using namespace std;

Helper::Helper(void)
{
}


Helper::~Helper(void)
{
}

void Helper::toLowerCase(std::string & input){
	std::transform(input.begin(), input.end(),input.begin(), ::tolower);
}

void Helper::toLowerCase(std::wstring &input){
	std::transform(input.begin(), input.end(),input.begin(), ::tolower);
}

bool Helper::isProcessExists(std::string t){
	DWORD ProcessesIDs[50], cbNeeded, cProcesses;
	unsigned int i;

	TCHAR szProcessName[50] = TEXT("<unknown>");

	if ( !EnumProcesses( ProcessesIDs, sizeof(ProcessesIDs), &cbNeeded ) )
		return false;

	cProcesses = cbNeeded / sizeof(DWORD);

	// This for loop will be enumerating each process.
	for ( i = 0; i < cProcesses; i++ )
	{
		HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
			FALSE, ProcessesIDs[i] );

		// Get the process name
		if (hProcess != NULL )
		{
			GetModuleBaseName( hProcess, NULL, szProcessName,
				sizeof(szProcessName)/sizeof(TCHAR) );
		}

		// convert to string
		std::wstring arr_w( szProcessName );
		std::string arr_s( arr_w.begin(), arr_w.end() );

		// case insensitive
		toLowerCase(arr_s);
		toLowerCase(t);

		// comparison of process
		if(arr_s.find(t) == 0){
			//_tprintf( TEXT("Process Name = %s, PID = %u \n"), szProcessName, ProcessesIDs[i]);
			return true;
		}

		CloseHandle( hProcess );
	}

	return false;
}

bool Helper::isRegistryKeyExists(HKEY hkey,LPTSTR lpSubKey ){
	/*LONG WINAPI RegOpenKeyEx(
	_In_        HKEY hKey,
	_In_opt_    LPCTSTR lpSubKey,
	_Reserved_  DWORD ulOptions,
	_In_        REGSAM samDesired,
	_Out_       PHKEY phkResult
	);
	*/
	HKEY key;
	LONG lResult;
	DWORD dwSize = 1024;

	lResult = RegOpenKeyEx(hkey, lpSubKey, 0, KEY_ALL_ACCESS|KEY_WOW64_64KEY, &key);
	if (lResult == ERROR_FILE_NOT_FOUND) {
		return false;
	}
	else{
		if(lResult == ERROR_SUCCESS){
			//enumerate
			/*DWORD index = 0;
			while (ERROR_SUCCESS == RegEnumKeyEx(key, index, name, &dwSize, NULL, NULL, NULL, NULL))
			{
			_tcprintf(TEXT("%s\n"), name);
			dwSize = 1024;
			++index;
			}*/
		}
		return true;
	}
}

bool Helper::isRegistryValue(HKEY h, wstring key,  wstring name, wstring checkString[], int size){
	DWORD type;
	DWORD cbData;
	HKEY hkey;
	wstring res;

	if (RegOpenKeyEx(h, key.c_str(), 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
		if(RegQueryValueEx(hkey, name.c_str(), NULL, &type, NULL, &cbData) == ERROR_SUCCESS){
			wstring value(cbData/sizeof(wchar_t), L'\0');
			if (RegQueryValueEx(hkey, name.c_str(), NULL, NULL, reinterpret_cast<LPBYTE>(&value[0]), &cbData) != ERROR_SUCCESS)
			{
				RegCloseKey(hkey);
				throw "Could not read registry value";
			}

			RegCloseKey(hkey);

			size_t firstNull = value.find_first_of(L'\0');
			if (firstNull != string::npos)
				value.resize(firstNull);

			res = value;

		}
	}

	// compare string
	toLowerCase(res);

	int i;
	for(i = 0; i < size; i++){
		//	toLowerCase(&checkString[i]);	
		//	wcout << checkString[i] << "\n";
		if(res.find(checkString[i]) != std::string::npos){
			//cout << "true\n";
			return true;
		}
	}


	return false;
}

bool Helper::isFileExists(string fileName){
	struct stat buf;
	if (stat(fileName.c_str(), &buf) != -1)
	{
		cout << fileName << " exists. \n";
		return true;
	}

	return false;

	/*wchar_t szBuff[1024];
	swprintf(szBuff, L"%s", fileName);

	cout << GetFileAttributes(szBuff) << "\n";
	if(GetLastError()==ERROR_FILE_NOT_FOUND)
	{
	return false;
	}
	else{
	cout << fileName << " exists. \n";
	return true;
	}*/
}

bool Helper::isStartWithMac(std::string input){
	// http://msdn.microsoft.com/en-us/library/aa365915(VS.85).aspx

	vector<std::string> macAddresses;
	IP_ADAPTER_INFO AdapterInfo[32];       // Allocate information for up to 32 NICs
	DWORD dwBufLen = sizeof(AdapterInfo);  // Save memory size of buffer
	DWORD dwStatus = GetAdaptersInfo(      // Call GetAdapterInfo
		AdapterInfo,                 // [out] buffer to receive data
		&dwBufLen);                  // [in] size of receive data buffer

	//No network card? Other error?
	if(dwStatus != ERROR_SUCCESS)
		return false;

	PIP_ADAPTER_INFO pAdapterInfo = AdapterInfo;
	char szBuffer[512];
	while(pAdapterInfo)
	{
		if(pAdapterInfo->Type == MIB_IF_TYPE_ETHERNET)
		{
			sprintf_s(szBuffer, sizeof(szBuffer), "%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"
				, pAdapterInfo->Address[0]
			, pAdapterInfo->Address[1]
			, pAdapterInfo->Address[2]
			, pAdapterInfo->Address[3]
			, pAdapterInfo->Address[4]
			, pAdapterInfo->Address[5]
			);
			macAddresses.push_back(szBuffer);
		}
		pAdapterInfo = pAdapterInfo->Next;
	}
	vector<std::string>::iterator itr = macAddresses.begin();
	while(itr != macAddresses.end()){
		toLowerCase(*itr);
		toLowerCase(input);
		if((signed)(*itr).find(input) != std::string::npos){
			cout << "Mac address found: " << *itr << "\n";
			return true;
		}

		itr++;
	}

	return false;
}

int Helper::getProcessID(std::string procName){
	HANDLE hProcessSnap;
	PROCESSENTRY32 pe32;
	int result = 0;

	// Take a snapshot of all processes in the system.
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	if( hProcessSnap == INVALID_HANDLE_VALUE )
	{
		return( FALSE );
	}

	// Set the size of the structure before using it.
	pe32.dwSize = sizeof( PROCESSENTRY32 );

	// Retrieve information about the first process,
	// and exit if unsuccessful
	if( !Process32First( hProcessSnap, &pe32 ) )
	{
		CloseHandle( hProcessSnap );          // clean the snapshot object
		return( FALSE );
	}

	// Now walk the snapshot of processes, and
	// display information about each process in turn
	int i = 0;
	do
	{
		//convert from wide char to narrow char array
		char ch[sizeof(pe32.szExeFile)];
		char DefChar = ' ';
		WideCharToMultiByte(CP_ACP,0,pe32.szExeFile,-1, ch,sizeof(pe32.szExeFile),&DefChar, NULL);
    
		//A std:string  using the char* constructor.
		std::string ss(ch);
		if(ss.compare(procName) == 0){
			result = pe32.th32ProcessID;
			break;
		}

	} while( Process32Next( hProcessSnap, &pe32 ) );

	CloseHandle( hProcessSnap );

	return result;
}

bool Helper::findWindows(LPCWSTR winname){
	HWND hnd = FindWindow(winname, 0);
	// add more debugger
	
	if (hnd)
		return true;
}